<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Crop and Create Image for print</title>
  <link rel="stylesheet" href="vendors/cropper/1.6.0/cropper.min.css" />
  <link rel="shortcut icon" href="favicon.png" type="image/x-icon" />
  <style type="text/css">
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      width: 100%;
      height: 100vh;
      display: flex;
      flex-direction: column;
      background-color: azure;
    }

    header,
    footer {
      padding: 20px;
      flex: 0 0 auto;
      background-color: aliceblue;
    }

    main {
      padding: 20px;
      flex: 1 0 auto;
    }

    img {
      width: 100%;
      border: 1px solid gray;
      display: block;
    }

    #cropImageWrapper {
      width: 360px;
      height: 450px;
      display: none;
    }

    #outputCanvas {
      width: 100%;
      max-width: 830px;
      background-color: white;
      box-shadow: 0 0 5px 2px rgba(0, 0, 0, 0.1);
      display: none;
    }
  </style>
</head>

<body>
  <header>
    <input type="file" name="imageInput" id="imageInput" accept="image/*" />
    <button id="cropButton" disabled>Crop Image</button>
    <button id="reCropButton" disabled>Re-Crop Image</button>

    <div id="canvasToolGroup">
      <select name="colsSelect" id="colsSelect" disabled>
        <option value="">Select col</option>
        <option value="1">One Col</option>
        <option value="2">Two Cols</option>
        <option value="3">Three Cols</option>
        <option value="4">Four Cols</option>
        <option value="5">Five Cols</option>
        <option selected value="6">Six Cols</option>
        <option value="7">Seven Cols</option>
        <option value="8">Eight Cols</option>
      </select>

      <select name="rowsSelect" id="rowsSelect" disabled>
        <option value="">Select Row</option>
        <option selected value="1">One Row</option>
        <option value="2">Two Rows</option>
        <option value="3">Three Rows</option>
        <option value="4">Four Rows</option>
        <option value="5">Five Rows</option>
        <option value="6">Six Rows</option>
        <option value="7">Seven Rows</option>
        <option value="8">Eight Rows</option>
      </select>
      <!-- <input type="color" id="backgroundColorSelect"> -->
      <input type="color" id="backgroundColorInput" disabled />

      <button id="downloadImageButton" disabled>Download Image</button>
    </div>
  </header>

  <main>
    <div id="cropImageWrapper">
      <img id="imageForCrop" src="select_picture.png" />
    </div>
    <br />

    <canvas id="outputCanvas">Your browser doesn't support.</canvas>
  </main>

  <footer>&copy; Copyright</footer>

  <script src="vendors/cropper/1.6.0/cropper.min.js"></script>
  <script type="text/javascript">
    "use strict";
    const _ = (e) => document.querySelector(e);
    const cropButton = _("#cropButton");
    const imageForCrop = _("#imageForCrop");
    const rowsSelect = _("#rowsSelect");
    const colsSelect = _("#colsSelect");
    const reCropButton = _("#reCropButton");
    const cropImageWrapper = _("#cropImageWrapper");
    const outputCanvas = _("#outputCanvas");

    let originalImageMimeType = null;
    let isImageLoaded = false;
    let cropper = null;

    let targetImageWidth = 360;
    let targetImageHeight = 450;

    let backgroundColor = "#008080"; // Default background color (white)

    const paperSize = {
      A4: { width: 2480, height: 3505 },
      _4x6: { width: 1200, height: 1800 },
      _5x7: { width: 1500, height: 2100 },
    };
    // set internally
    const gap = 50; // Adjust gap as needed
    const margin = gap / 2;

    // Handle image input change event
    _("#imageInput").addEventListener("change", handleImage);
    // Handle background color input change event
    _("#backgroundColorInput").addEventListener("input", setBackgroundColor);
    // Handle rows select change event
    rowsSelect.addEventListener("change", updateGrid);
    // Handle columns select change event
    colsSelect.addEventListener("change", updateGrid);
    reCropButton.addEventListener("click", function () {
      cropButton.disabled = false;
      cropImageWrapper.style.display = "block";
      outputCanvas.style.display = "none";
      this.disabled = true;
    });
    // Handle download button click
    const downloadImageButton = _("#downloadImageButton");

    downloadImageButton.addEventListener("click", downloadCanvas);

    // get from user
    let numRows = parseInt(rowsSelect.value, 10) || 1; // Default number of rows
    let numCols = parseInt(colsSelect.value, 10) || 6; // Default number of columns

    cropButton.addEventListener("click", cropImage);

    // detect upload image
    function handleImage(event) {
      const file = event.target.files[0];
      if (file) {
        originalImageMimeType = file.type;
        // image onload
        imageForCrop.onload = function () {
          isImageLoaded = true;
          // console.log("image loaded");
          initCropper();
          cropImageWrapper.style.display = "block";

          // enable cropButton
          cropButton.disabled = false;
        };
        imageForCrop.src = URL.createObjectURL(file);
      }

      let files = event.target.files;
      // console.log(event);
      // console.log(files);
    }

    // initialisation of cropper
    function initCropper() {
      if (cropper) {
        destroyCrooper();
      }

      cropper = new Cropper(imageForCrop, {
        viewMode: 3,
        dragMode: "move",
        aspectRatio: 20 / 25,
        autoCropArea: 1,
        restore: !1,
        modal: !1,
        highlight: !1,
        cropBoxMovable: !1,
        cropBoxResizable: !1,
        toggleDragModeOnDblclick: !1,
      });
    }

    function destroyCrooper() {
      cropper.destroy();
      cropper = null;
    }

    function cropImage() {
      if (cropper) {
        const croppedCanvas = cropper.getCroppedCanvas({
          width: targetImageWidth,
          height: targetImageHeight,
        });

        croppedCanvas.toBlob(function (blob) {
          const croppedImageUrl = URL.createObjectURL(blob);
          // enable tools
          diableTools(false);
          drawImageGrid();
          reCropButton.disabled = false;
          cropButton.disabled = true;
          cropImageWrapper.style.display = "none";
          outputCanvas.style.display = "block";
          // console.log(croppedImageUrl);
        }, originalImageMimeType, 1);
      }
    }

    function diableTools(status) {
      document
        .querySelectorAll("#canvasToolGroup>*")
        .forEach((el) => (el.disabled = status));
    }

    // outputCanvas grid
    const ctx = outputCanvas.getContext("2d");
    outputCanvas.width = paperSize.A4.width; // Adjust outputCanvas size as needed
    outputCanvas.height = paperSize.A4.height;

    let outputCanvasImageBlob = null;

    function drawImageGrid() {
      if (isImageLoaded) {
        // set background colour white
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
        // arrange image in rows by for loop
        for (let row = 0; row < numRows; row++) {
          // arrange image in columns by for loop
          for (let col = 0; col < numCols; col++) {
            const x = col * (targetImageWidth + gap) + margin; // Adjusted x position
            const y = row * (targetImageHeight + gap) + margin; // Adjusted y position

            // for maintain original image ratio
            // const y = row * (img.height / img.width * targetImageWidth + gap) + margin; // Adjusted y position

            ctx.fillStyle = backgroundColor;
            ctx.fillRect(x, y, targetImageWidth, targetImageHeight);

            ctx.strokeStyle = "black";
            ctx.lineWidth = 5;

            ctx.drawImage(
              imageForCrop, x, y, targetImageWidth, targetImageHeight
            );

            ctx.strokeRect(x, y, targetImageWidth, targetImageHeight); // Stroke around the image
          }
        }
      }

      // Store outputCanvas image as Blob
      outputCanvas.toBlob(function (blob) {
        outputCanvasImageBlob = blob;
      }, originalImageMimeType); // Pass original image MIME type
    }

    function setBackgroundColor(event) {
      backgroundColor = event.target.value;
      ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
      drawImageGrid();
    }

    function updateGrid() {
      numRows = parseInt(rowsSelect.value, 10);
      numCols = parseInt(colsSelect.value, 10);
      ctx.clearRect(0, 0, outputCanvas.width, outputCanvas.height);
      drawImageGrid();
    }

    function downloadCanvas() {
      if (outputCanvasImageBlob) {
        const timestamp = new Date().getTime();
        const fileName = `IMG_${timestamp}.png`;
        const link = document.createElement("a");
        link.download = fileName;
        link.href = URL.createObjectURL(outputCanvasImageBlob);
        link.click();
      }
    }

    setBackgroundColor({ target: { value: backgroundColor } });

  </script>
</body>

</html>
